# Инструкция по работе с git

## Что это и для чего нужна система контроля версий?
Git — это набор консольных утилит, которые отслеживают и фиксируют изменения в файлах (чаще всего речь идет об исходном коде программ, но вы можете использовать его для любых файлов на ваш вкус). Изначально Git был создан Линусом Торвальдсом при разработке ядра Linux. Однако инструмент так понравился разработчикам, что в последствии, он получил широкое распространение и его стали использовать в других проектах. С его помощью вы можете сравнивать, анализировать, редактировать, сливать изменения и возвращаться назад к последнему сохранению. Этот процесс называется контролем версий.
Для чего он нужен? Ну во-первых, чтобы отследить изменения, произошедшие с проектом, со временем. Проще говоря, мы можем посмотреть как менялись файлы программы, на всех этапах разработки и при необходимости вернуться назад и что-то отредактировать. Часто бывают ситуации, когда, во вполне себе работающий код, вам нужно внести определенные правки или улучшить какой-то функционал, по желанию заказчика. Однако после внедрения нововведений, вы с ужасом понимаете, что все сломалось. У вас начинается судорожно дергаться глаз, а в воздухе повисает немой вопрос: “Что делать?” Без системы контроля версий, вам надо было бы долго напряженно просматривать код, чтобы понять как было до того, как все перестало работать. С Гитом же, все что нужно сделать - это откатиться на коммит назад.
Во-вторых он чрезвычайно полезен при одновременной работе нескольких специалистов, над одним проектом. Без Гита случится коллапс, когда разработчики, скопировав весь код из главной папки и сделав с ним задуманное, попытаются одновременно вернуть весь код обратно.
Git является распределенным, то есть не зависит от одного центрального сервера, на котором хранятся файлы. Вместо этого он работает полностью локально, сохраняя данные в директориях на жестком диске, которые называются репозиторием. Тем не менее, вы можете хранить копию репозитория онлайн, это сильно облегчает работу над одним проектом для нескольких людей. Для этого используются сайты вроде github и bitbucket.

### Что такое система контроля версий?
Система контроля версий (от англ. Version Control System, VCS) — это место хранения кода. Как dropbox, только для разработчиков!
Она заточена именно на разработку продуктов. То есть на хранение кода, синхронизацию работы нескольких человек, создание релизов (бранчей)... Но давайте я лучше расскажу на примере, чем она лучше дропбокса. Всё как всегда, история с кучей картиночек для наглядности ))
А потом я подробнее расскажу, как VCS работает — что значит "создать репозиторий", "закоммитить и смерджить изменения", и другие страшные слова. В конце мы пощупаем одну из систем VCS руками, скачаем код из открытого репозитория.

**Система контроля версий** - *это система, записывающая изменения в файл или набор файлов в течение времени, позволяющая вернуться позже к определенное версии*.

### Для чего нужна система контроля версий
Допустим, что мы делаем калькулятор на Java (язык программирования). У нас есть несколько разработчиков — Вася, Петя и Иван. Через неделю нужно показывать результат заказчику, так что распределяем работу:

Вася делает сложение;
Петя — вычитание;
Иван — начинает умножение, но оно сложное, поэтому переедет в следующий релиз.

Исходный код калькулятора хранится в обычной папке на сетевом диске, к которому все трое имеют доступ. Разработчик копирует этот код к себе на машину, вносит изменения и проверяет. Если всё хорошо — кладет обратно. Так что код в общей папке всегда рабочий!
![прикольная картинка ветка](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d73/ab7/ed1/d73ab7ed183389f7226b4b3f21cf9e2e.png)
Итак, все забрали себе файлы из общей папки. Пока их немного:
* Main.java — общая логика
* GUI.java — графический интерфейс программы

С ними каждый и будет работать!
Вася закончил работу первым, проверил на своей машине — все работает, отлично! Удовлетворенно вздохнув, он выкладывает свой код в общую папку. Вася сделал отдельный класс на сложение (Sum.java), добавил кнопку в графический интерфейс (внес изменения в GUI.java) и прописал работу кнопки в Main.java.
![прикольная картинка ветка](https://habrastorage.org/r/w1560/getpro/habr/upload_files/746/d5e/2a0/746d5e2a06baba4a46344b11c8b311c6.png)
Петя химичил-химичил, ускорял работу, оптимизировал... Но вот и он удовлетворенно вздохнул — готово! Перепроверил ещё раз — работает! Он копирует файлы со своей машины в общую директорию. Он тоже сделал отдельный класс для новой функции (вычитание — Minus.java), внес изменения в Main.java и добавил кнопку в GUI.java.
![прикольная картинка ветка](https://habrastorage.org/r/w1560/getpro/habr/upload_files/c7b/fae/81a/c7bfae81a3d6d1cb6f3fb5ff783c0ae8.png)
Ваня пока химичит на своей машине, но ему некуда торопиться, его изменения попадут только в следующий цикл.
Все довольны, Вася с Петей обсуждают планы на следующий релиз. Но тут с показа продукта возвращается расстроенная Катя, менеджер продукта.
— Катя, что случилось??
— Вы же сказали, что всё сделали! А в графическом интерфейсе есть только вычитание. Сложения нет!

Вася удивился:
— Как это нет? Я же добавлял!
Стали разбираться.  Оказалось, что Петин файл затер изменения Васи в файлах, которые меняли оба: Main.java и GUI.java. Ведь ребята одновременно взяли исходные файлы к себе на компьютеры — у обоих была версия БЕЗ новых функций.
Вася первым закончил работу и обновил все нужные файлы в общей папке. Да, на тот момент всё работало. Но ведь Петя работал в файле, в котором ещё не было Васиных правок.
Поэтому, когда он положил документы в хранилище, Васины правки были стерты. Остался только новый файл Sum.java, ведь его Петя не трогал.
Хорошо хоть логика распределена! Если бы всё лежало в одном классе, было бы намного сложнее совместить правки Васи и Пети. А так достаточно было немного подправить файлы Main.java и GUI.java, вернув туда обработку кнопки. Ребята быстро справились с этим, а потом убедились, что в общем папке теперь лежит правильная версия кода.

Собрали митинг (жаргон — собрание, чтобы обсудить что-то):
— Как нам не допустить таких косяков в дальнейшем?
— Давайте перед тем, как сохранять файлы в хранилище, забирать оттуда последние версии! А ещё можно брать свежую версию с утра. Например, в 9 часов. А перед сохранением проверять дату изменения. Если она позже 9 утра, значит, нужно забрать измененный файл.
— Да, давайте попробуем!

Вася с Петей были довольны, ведь решение проблемы найдено! И только Иван грустит. Ведь он целую неделю работал с кодом, а теперь ему надо было синхронизировать версии... То есть объединять свои правки с изменениями коллег.
Доделав задачу по умножению, Иван синхронизировал свои файлы с файлами из хранилища. Это заняло половину рабочего дня, но зато он наконец-то закончил работу! Довольный, Иван выключил компьютер и ушел домой.

Когда он пришел с утра, в офисе был переполох. Вася бегал по офису и причитал:
— Мои изменения пропали!!! А я их не сохранил!

Увидев Ваню, он подскочил к нему и затряс за грудки:
— Зачем ты стер мой код??

Стали разбираться. Оказалось что Вася вчера закончил свой кусок работы, проверил, что обновлений файлов не было, и просто переместил файлы со своего компьютера в общую папку. Не скопировал, а переместил. Копий никаких не осталось.
После этого изменения вносил Иван. Да, он внимательно вычитывал файлы с кодом и старался учесть и свои правки, и чужие. Но изменений слишком много, часть Васиных правок он потерял.
— Код теперь не работает! Ты вообще проверял приложение, закончив синхронизацию?
— Нет, я только свою часть посмотрел...

Вася покачал головой:
— Но ведь при сохранении на общий диск можно допустить ошибку! По самым разным причинам:

Разработчик начинающий, чаще допускает ошибки.
Случайно что-то пропустил — если нужно «объединить» много файлов, что-то обязательно пропустишь.
Посчитал, что этот код не нужен — что он устарел или что твоя новая логика делает то же самое, а на самом деле не совсем.
И тогда приложение вообще перестанет работать. Как у нас сейчас.

Ваня задумался:
— Хм... Да, пожалуй, ты прав. Нужно тестировать итоговый вариант!

Петя добавил:
— И сохранять версии. Может, перенесем наш код в Dropbox, чтобы не терять изменения?

На том и порешили. Остаток дня все трое работали над тем, чтобы приложение снова заработало. После чего бережно перенесли код в дропбокс. Теперь по крайней мере сохранялись старые версии. И, если разработчик криво синхронизировал файлы или просто залил свои, затерев чужие изменения, можно было найти старую версию и восстановить ее.

Через пару дней ребята снова собрали митинг:
— Ну как вам в дропбоксе?
— Уже лучше. По крайней мере, не потеряем правки!

Петя расстроенно пожимает плечами:
— Да, только мы с Васей одновременно вносили изменения в Main.java, создалась конфликтующая версия. И пришлось вручную их объединять... А класс то уже подрос! И глазками сравнивать 100 строк очень невесело... Всегда есть шанс допустить ошибку.
— Ну, можно же подойти к тому, кто создал конфликт и уточнить у него, что он менял.
— Хорошая идея, давайте попробуем!

Попробовали. Через несколько дней снова митинг:
— Как дела?
— Да всё зашибись, работаем!
— А почему код из дропбокса не работает?
— Как не работает??? Мы вчера с Васей синхронизировались!
— А ты попробуй его запустить.

Посмотрели все вместе — и правда не работает. Какая-то ошибка в Main.java. Стали разбираться:
— Так, тут не хватает обработки исключения.
— Ой, подождите, я же её добавлял!
— Но ты мне не говорил о ней, когда мы объединяли правки.
— Да? Наверное, забыл...
— Может, еще что забыл? Ну уж давай лучше проверим глазами...

Посидели, выверили конфликтные версии. Потратили час времени всей команды из-за пустяка. Обидно!
— Слушайте, может, это можно как-то попроще делать, а? Чтобы человека не спрашивать «что ты менял»?
— Можно использовать программу сравнения файлов. Я вроде слышал о таких. AraxisMerge, например!
— Ой, точно! В IDEA же можно сравнивать твой код с клипбордом (сохраненным в Ctrl + C значении). Давайте использовать его!
— Точно!

Начали сравнивать файлы через программу — жизнь пошла веселее. Но через пару дней Иван снова собрал митинг:
— Ребята, тут такая тема! Оказывается, есть специальные программы для хранения кода! Они хранят все версии и показывают разницу между ними. Только делает это сама программа, а не человек!
— Да? И что за программы?
— Системы контроля версий называются. Вот SVN, например. Давайте попробуем его?
— А давайте!

Попробовали. Работает! Еще и часть правок сама синхронизирует, даже если Вася с Петей снова не поделили один файл. Как она это делает? Давайте разбираться!

## Установка git и VSCode на ваш ПК.

<code>[https://code.visualstudio.com/](VSCode)
</code>
<code>[https://git-scm.com/](Git)
</code> 

### Установка VSCode на ваш ПК.

### Установка git на ваш ПК

1. **Установка на Mac**
                
    Существует несколько способов установки Git на **_Mac_**. Самый простой — установить Xcode Command Line Tools. В версии Mavericks (10.9) и выше вы можете добиться этого просто первый раз выполнив 'git' в терминале.

        $ git --version
        
    Если Git не установлен, вам будет предложено его установить.

    Если Вы хотите получить более актуальную версию, то можете воспользоваться бинарным установщиком. Установщик Git для OS X доступен для скачивания с сайта Git https://git-scm.com/download/mac.

2. **Установка на Linux** 
        
    Если вы хотите установить Git под **_Linux_** как бинарный пакет, это можно сделать, используя обычный менеджер пакетов вашего дистрибутива. Если у вас Fedora (или другой похожий дистрибутив, такой как RHEL или CentOS), можно воспользоваться dnf:

        $ sudo dnf install git-all
    
    Если же у вас дистрибутив, основанный на Debian, например, Ubuntu, попробуйте apt:

        $ sudo apt install git
    Чтобы воспользоваться дополнительными возможностями, посмотрите инструкцию по установке для нескольких различных разновидностей Unix на сайте Git https://git-scm.com/download/linux.

3. **Установка на Windows**
        
    Для установки Git в **_Windows_** также имеется несколько способов. Официальная сборка доступна для скачивания на официальном сайте Git. Просто перейдите на страницу https://git-scm.com/download/win, и загрузка запустится автоматически. Обратите внимание, что это отдельный проект, называемый Git для Windows; для получения дополнительной информации о нём перейдите на https://gitforwindows.org.

    Для автоматической установки вы можете использовать пакет Git Chocolatey. Обратите внимание, что пакет Chocolatey поддерживается сообществом.


#### Первая настройка git

## Создание и базовая работа с локальным репозиторием.

### Что такое репозиторий и инструкция по созданию локальных репозиториев.<br>

 > **Репозиторий** - папка, действия в которой отслеживаются программой ( операции выполняемые над репозиторием, индекс, описывающий расположение файлов, и хранилище, содержащее собственно файлы).

* Для создания репозитория необходимо создать *новую папку*, не содержащую репозиториев и не являющуюся частью другого репозитория.
* Далее в терминале запускаем **git init** - команду для создания репозитория в выбранной папке
в результате выполнения git init появляется скрытая папка .git


### Базовая работа с локальным репозиторием

![прикольная картинка локальный репозиторий](https://avatars.mds.yandex.net/i?id=f4ef2c479b107406238ecfe597039757-5464818-images-thumbs&n=13
)

*git --version* - **Команда для вывода версии системы управления версиями**

*git init* - **Команда для инициализации пустого репозитория**

*git status* - **Команда для проверки измениний файла**

*git add* - **Команда для добавления версионности к файлу**

*git stash* - **Команда для размещения изменений в отдельное хранилище, и возвращение файла к исходному состоянию.**

*git commit -m "messege"* - **Команда для фиксации изменений файла**

*git log* - **Команда для вывода журнала коммитов**

*git diff* - **Команда для вывода разницы между последним коммитом и текущими изменениями**

## Полезные команды для работы с консолью

*clear* - **Команда для очистки консоли**

*mkdir* - **Команда для создания нового каталога**

*touch* - **Команда для создания нового файла**

*cd* - **Команда для смены директории**

## Ветки. Локальная работа с ветками в git.

![прикольная картинка ветка](https://avatars.mds.yandex.net/i?id=8eba87b02c2ba309123eda8c7d433144-5715888-images-thumbs&n=13
)

*git branch* - **Команда для вывода всех доступных ветвей**

*git branch name* - **Команда для создания новой ветви с именем name**

*git checkout name* - **Команда для перехода на указанную ветвь**

*git merge* - **Команда для слияния ветвей. __Внимание!__ Команда должна вызываться из ветви в которую будет выполнятся слияние!**

*git branch -d name* - **Команда для удаления ветви name**





### Что такое ветки и для чего они нужны при работе с системой контроля версий.

### Базовая работа с ветками в git.

## Работа с удаленными репозиториями.

### Что такое удаленный репозиторий и для чего он нужен

### Базовая работа с удаленными репозиториями GitHub

1. Для работы с удалённым репозиторием необходимо совершить Fork на GitGub.
2. Далее необходимо скопировать ссылку в ниспадающем меню "Code".
3. И с помощью команды (git clone ссылка_на_форк)
4. Перед этим всем необходимо сделать git init для создания локального репозитория и для возможности осуществлять нашу магию!
5. А далее используем все как обычно: git add, git commit -m
6. Далее push - отправляем наши данные в GitHub
7. Последнее  - осуществление pull request на GitHub. Соответственно комит на GitHub. В принципе, вуаля, все данные отправлены владельцу сетевого репозитория для согласования merga наших даных гита и данных гита владельца.

Основы работы с удаленным репозиторием

**git clone** — создание копии (удаленного) репозитория

Для начала работы с центральным репозиторием, следует создать копию оригинального проекта со всей его историей локально.
Клонирует репозиторий, используя протокол http

**git fetch и git pull** — забираем изменения из центрального репозитория

## Совместная работа над проектом (fork, pull request)

### Как строится и для чего нужна совместная работа в системах контроля версий

### Инструкция по созданию pull request
>* Делаем   (ответвление) репозитория fork
>* Делаем *git clone*   версии репозитория **СВОЕЙ**
>* Создаем новую ветку и в **НЕЕ** вносим свои изменения
>* Фиксируем изменения (делаем коммиты)
>* Отправляем свою версию в свой *GitHub*
>* На сайте GitHub нажимаем кнопку *pull request*


## Книги и полезные ссылки по изучению git.

## Альтернативные системы контроля версий.
